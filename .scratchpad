# 当前任务：重构渲染范围控制

## 任务分析
- 将渲染范围控制逻辑从 useWaveformDrawer 移到独立的状态管理中
- 使用 Pinia store 确保状态在多个组件间同步

## 任务进度
[X] 创建 viewport store
[X] 修改 useWaveformDrawer 使用 viewport store
[X] 修改 useAudioVisualizer 使用 viewport store
[X] 修改页面组件使用 viewport store
[X] 添加渲染范围的百分比控制
[X] 优化时间轴显示，使用整数秒刻度

## 下一步
1. 优化渲染性能
   - 只渲染可见区域的波形
   - 添加缓存机制避免重复计算
   - 优化大文件加载性能

## 注意事项
- 确保渲染范围的变化能实时反映在界面上
- 添加合适的动画效果提升用户体验
- 考虑极端情况（如音频时长很短或很长）的处理

## 已解决的问题
1. 渲染范围控制已经从组件移到 Pinia store
2. 界面显示更直观（百分比 + 具体时间）
3. 时间轴显示更清晰（整数秒刻度）

## 待解决的问题
1. 大文件加载时的性能优化
2. 波形渲染的缓存机制
3. 极端情况的处理（如很长的音频文件）

# 当前任务
优化 canvas 渲染性能，通过控制渲染的时间范围来限制渲染内容

# 任务分析
1. 核心思路：添加 renderStartTime 和 renderEndTime 来控制渲染范围
2. 主要改动：
   - 添加渲染范围的状态管理
   - 修改绘制函数以支持范围渲染
   - 确保坐标转换和事件处理正确处理偏移
3. 关键点：
   - 保持现有功能正常工作
   - 确保性能提升
   - 维持良好的用户体验

# 实施计划
## 阶段一：添加渲染范围控制
[X] 1.1 在 useWaveformDrawer 中添加基础状态
[X] 1.2 添加渲染范围的 getter/setter
[X] 1.3 测试范围设置的正确性

## 阶段二：修改时间轴渲染
[X] 2.1 修改 drawTimeAxis 支持范围渲染
[X] 2.2 确保时间刻度正确显示
[X] 2.3 测试不同缩放级别下的显示

## 阶段三：修改波形渲染
[X] 3.1 修改 drawWaveform 支持范围渲染
[X] 3.2 添加波形数据缓存
[X] 3.3 优化内存访问和渲染性能

## 阶段四：修改标注区域渲染
[X] 4.1 修改 drawRegions 支持范围渲染
[X] 4.2 优化标注区域的性能
[X] 4.3 修复类型安全问题

## 阶段五：优化交互处理
[ ] 5.1 修改坐标转换逻辑
    - 在 viewport store 中添加坐标转换方法
    - 修改所有使用坐标转换的地方
    - 确保考虑渲染区间的影响
[ ] 5.2 确保拖拽和点击正确工作
[ ] 5.3 测试所有交互功能

## 阶段六：性能测试和优化
[ ] 6.1 测试长音频文件的性能
[ ] 6.2 测试不同操作下的响应速度
[ ] 6.3 进行必要的性能优化

# 当前阶段：阶段五开始，准备修复坐标转换逻辑

## 坐标转换修复方案
1. 在 viewport store 中添加坐标转换方法：
   - getTimeFromX: 像素坐标转换为时间
   - getXFromTime: 时间转换为像素坐标

2. 修改内容：
   - 考虑视口的起始时间（startTime）
   - 使用视口时长（viewDuration）而不是总时长
   - 确保坐标和时间都在合理范围内

3. 预期效果：
   - 鼠标位置能正确对应到视口内的时间
   - 拖拽操作的位置计算准确
   - 标注区域的位置显示正确

## 注意事项
- 确保坐标转换的一致性
- 处理边界情况
- 保持良好的代码组织

# 测试要点
每个阶段完成后，需要验证：
1. 基础功能是否正常
2. 是否有明显的性能提升
3. 用户体验是否良好
4. 是否有边界情况问题
